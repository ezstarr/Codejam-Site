<!DOCTYPE HTML>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>first-person</title>
  <link rel="shortcut icon" sizes="16x16 32x32 48x48 64x64 128x128 256x256" href="/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Try out Elm: A delightful language with friendly error messages, great performance, small assets, and no runtime exceptions.">
  <link rel="stylesheet" rel="preload" href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans|Courier+Prime&display=swap">
  <link rel="stylesheet" href="/assets/editor-styles.css"/>
</head>

<body>
<svg xmlns="http://www.w3.org/2000/svg" style="display:none;">
  <symbol id="logo" viewBox="-300 -300 600 600" fill="currentColor">
    <g transform="scale(1 -1)">
    <polygon points="-280,-90 0,190 280,-90" transform="translate(0 -210) rotate(0)"></polygon>
      <polygon points="-280,-90 0,190 280,-90" transform="translate(-210 0) rotate(-90)"></polygon>
      <polygon points="-198,-66 0,132 198,-66" transform="translate(207 207) rotate(-45)"></polygon>
      <polygon points="-130,0 0,-130 130,0 0,130" transform="translate(150 0) rotate(0)"></polygon>
      <polygon points="-191,61 69,61 191,-61 -69,-61" transform="translate(-89 239) rotate(0)"></polygon>
      <polygon points="-130,-44 0,86  130,-44" transform="translate(0 106) rotate(-180)"></polygon>
      <polygon points="-130,-44 0,86  130,-44" transform="translate(256 -150) rotate(-270)"></polygon>
    </g>
  </symbol>
</svg>

<main id="main"></main>
<textarea id="original" style="display:none;">-- Walk around in 3D space using the keyboard.
--
-- Dependencies:
--   elm install elm-explorations/linear-algebra
--   elm install elm-explorations/webgl
--
-- Try adding the ability to crouch or to land on top of the crate!
--


import Browser
import Browser.Dom as Dom
import Browser.Events as E
import Html exposing (Html, p, text, div)
import Html.Attributes exposing (width, height, style)
import Json.Decode as D
import Math.Matrix4 as Mat4 exposing (Mat4)
import Math.Vector2 as Vec2 exposing (Vec2, vec2)
import Math.Vector3 as Vec3 exposing (Vec3, vec3)
import Task
import WebGL
import WebGL.Texture as Texture



-- MAIN


main : Program () Model Msg
main =
  Browser.element
    { init = init
    , view = view
    , update = \msg model -> (update msg model, Cmd.none)
    , subscriptions = subscriptions
    }



-- MODEL


type alias Model =
  { keys : Keys
  , width : Float
  , height : Float
  , person : Person
  , texture : Maybe Texture.Texture
  }


type alias Keys =
  { up : Bool
  , left : Bool
  , down : Bool
  , right : Bool
  , space : Bool
  }


type alias Person =
  { position : Vec3
  , velocity : Vec3
  }


init : () -> ( Model, Cmd Msg )
init _ =
  ( { keys = noKeys
    , width = 400
    , height = 400
    , person = Person (vec3 0 eyeLevel -10) (vec3 0 0 0)
    , texture = Nothing
    }
  , Cmd.batch
      [ Task.attempt GotTexture (Texture.load "https://elm-lang.org/images/wood-crate.jpg")
      , Task.perform (\{viewport} -> Resized viewport.width viewport.height) Dom.getViewport
      ]
  )


eyeLevel : Float
eyeLevel =
  2


noKeys : Keys
noKeys =
  Keys False False False False False



-- UPDATE


type Msg
  = GotTexture (Result Texture.Error Texture.Texture)
  | KeyChanged Bool String
  | TimeDelta Float
  | Resized Float Float
  | VisibilityChanged E.Visibility


update : Msg -> Model -> Model
update msg model =
  case msg of
    GotTexture result ->
      { model | texture = Result.toMaybe result }

    KeyChanged isDown key ->
      { model | keys = updateKeys isDown key model.keys }

    TimeDelta dt ->
      { model | person = updatePerson dt model.keys model.person }

    Resized width height ->
      { model
          | width = width
          , height = height
      }

    VisibilityChanged _ ->
      { model | keys = noKeys }


updateKeys : Bool -> String -> Keys -> Keys
updateKeys isDown key keys =
  case key of
    " "          -> { keys | space = isDown }
    "ArrowUp"    -> { keys | up    = isDown }
    "ArrowLeft"  -> { keys | left  = isDown }
    "ArrowDown"  -> { keys | down  = isDown }
    "ArrowRight" -> { keys | right = isDown }
    _            -> keys


updatePerson : Float -> Keys -> Person -> Person
updatePerson dt keys person =
  let
    velocity = stepVelocity dt keys person
    position = Vec3.add person.position (Vec3.scale (dt / 500) velocity)
  in
  if Vec3.getY position < eyeLevel then
    { position = Vec3.setY eyeLevel position
    , velocity = Vec3.setY 0 velocity
    }
  else
    { position = position
    , velocity = velocity
    }


stepVelocity : Float -> Keys -> Person -> Vec3
stepVelocity dt { left, right, up, down, space } person =
  if Vec3.getY person.position > eyeLevel then
    Vec3.setY (Vec3.getY person.velocity - dt / 250) person.velocity
  else
    let
      toV positive negative =
        (if positive then 1 else 0) - (if negative then 1 else 0)
    in
    vec3 (toV left right) (if space then 2 else 0) (toV up down)



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
  Sub.batch
    [ E.onResize (\w h -> Resized (toFloat w) (toFloat h))
    , E.onKeyUp (D.map (KeyChanged False) (D.field "key" D.string))
    , E.onKeyDown (D.map (KeyChanged True) (D.field "key" D.string))
    , E.onAnimationFrameDelta TimeDelta
    , E.onVisibilityChange VisibilityChanged
    ]



-- VIEW


view : Model -> Html Msg
view model =
  let
    entities =
      case model.texture of
        Nothing ->
          []

        Just texture ->
          [ viewCrate model.width model.height model.person texture ]
  in
  div
    [ style "position" "absolute"
    , style "left" "0"
    , style "top" "0"
    , style "width" (String.fromFloat model.width ++ "px")
    , style "height" (String.fromFloat model.height ++ "px")
    ]
    [ WebGL.toHtmlWith [ WebGL.depth 1, WebGL.clearColor 1 1 1 1 ]
        [ style "display" "block"
        , width (round model.width)
        , height (round model.height)
        ]
        entities
    , keyboardInstructions model.keys
    ]


viewCrate : Float -> Float -> Person -> Texture.Texture -> WebGL.Entity
viewCrate width height person texture =
  let
    perspective =
      Mat4.mul
        (Mat4.makePerspective 45 (width / height) 0.01 100)
        (Mat4.makeLookAt person.position (Vec3.add person.position Vec3.k) Vec3.j)
  in
  WebGL.entity vertexShader fragmentShader crate
    { texture = texture
    , perspective = perspective
    }


keyboardInstructions : Keys -> Html msg
keyboardInstructions keys =
  div
    [ style "position" "absolute"
    , style "font-family" "monospace"
    , style "text-align" "center"
    , style "left" "20px"
    , style "right" "20px"
    , style "top" "20px"
    ]
    [ p [] [ text "Walk around with a first person perspective." ]
    , p [] [ text "Arrows keys to move, space bar to jump." ]
    ]



-- MESH


type alias Vertex =
  { position : Vec3
  , coord : Vec2
  }


crate : WebGL.Mesh Vertex
crate =
  WebGL.triangles <| List.concatMap rotatedSquare <|
    [ (0, 0)
    , (90, 0)
    , (180, 0)
    , (270, 0)
    , (0, 90)
    , (0, -90)
    ]


rotatedSquare : (Float, Float) -> List (Vertex, Vertex, Vertex)
rotatedSquare ( angleXZ, angleYZ ) =
  let
    transformMat =
      Mat4.mul
        (Mat4.makeRotate (degrees angleXZ) Vec3.j)
        (Mat4.makeRotate (degrees angleYZ) Vec3.i)

    transform vertex =
      { vertex
          | position =
              Mat4.transform transformMat vertex.position
      }

    transformTriangle (a, b, c) =
      (transform a, transform b, transform c)
  in
  List.map transformTriangle square


square : List ( Vertex, Vertex, Vertex )
square =
  let
    topLeft     = Vertex (vec3 -1  1  1) (vec2 0 1)
    topRight    = Vertex (vec3  1  1  1) (vec2 1 1)
    bottomLeft  = Vertex (vec3 -1 -1  1) (vec2 0 0)
    bottomRight = Vertex (vec3  1 -1  1) (vec2 1 0)
  in
  [ ( topLeft, topRight, bottomLeft )
  , ( bottomLeft, topRight, bottomRight )
  ]



-- SHADERS


type alias Uniforms =
  { texture : Texture.Texture
  , perspective : Mat4
  }


vertexShader : WebGL.Shader Vertex Uniforms { vcoord : Vec2 }
vertexShader =
  [glsl|
    attribute vec3 position;
    attribute vec2 coord;
    uniform mat4 perspective;
    varying vec2 vcoord;

    void main () {
      gl_Position = perspective * vec4(position, 1.0);
      vcoord = coord;
    }
  |]


fragmentShader : WebGL.Shader {} Uniforms { vcoord : Vec2 }
fragmentShader =
  [glsl|
    precision mediump float;
    uniform sampler2D texture;
    varying vec2 vcoord;

    void main () {
      gl_FragColor = texture2D(texture, vcoord);
    }
  |]</textarea>
<script src="/assets/editor-codemirror.js"></script>
<script src="/assets/editor-custom-elements.js"></script>
<script src="/assets/editor-elm.js"></script>
<script>
  window.addEventListener('load', function() {
    var originalCode = document.getElementById('original').textContent;
    main = Elm.Page.Editor.init({
      node: document.getElementById('main'),
      flags: {
        name: "first-person",
        width: window.innerWidth,
        height: window.innerHeight,
        original: document.getElementById('original').textContent,
        dependencies: { "direct": {
    "elm/browser": "1.0.2",
    "elm/core": "1.0.5",
    "elm/html": "1.0.0",
    "elm/json": "1.1.3",
    "elm-explorations/linear-algebra": "1.0.3",
    "elm-explorations/webgl": "1.1.3"
  },
  "indirect": {
    "elm/time": "1.0.0",
    "elm/url": "1.0.0",
    "elm/virtual-dom": "1.0.2"
  }
}
      }
    });

    main.ports.submitSource.subscribe(function(source) {
      var editorNode = document.getElementById('editor');
      var codeNode = document.getElementById('code');
      codeNode.value = source;
      editorNode.submit();
    });

    window.addEventListener("message", gotErrors, false);

    function gotErrors(event) {
      if (event.origin !== "https://elm.studio" && event.origin !== "https://social.elm.studio") return;
      if (event.data == "SUCCESS") {
        main.ports.gotSuccess.send(null);
      } else {
        var message = JSON.parse(event.data);
        main.ports.gotErrors.send(message);
      }
    }

    window.addEventListener("error", function (e) {
      main.ports.gotJsError.send(e.error.message);
      return false;
    });

  });
</script>

</body>

</html>

